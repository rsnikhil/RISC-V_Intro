% Intro to RISC-V ISA (Generic)

\documentclass{article}

\newcommand{\docversion}{v2022-12-14.1}

\usepackage{graphicx}
\usepackage{blindtext}
\usepackage{fancyhdr}
\usepackage{hyperref}

% Using "US legal" sized paper for roughly 16:10/16:9 ratio for slides
% 16:10 = 1.6, 16/9 = 1.77
% Legal size is 14"x8.5" = 1.64
\usepackage[legalpaper, landscape]{geometry}
% \usepackage[letterpaper, landscape]{geometry}

\geometry{tmargin=0.7in}
\geometry{bmargin=0.6in}

\geometry{lmargin=0.2in}
\geometry{rmargin=0.2in}

% ----------------

\newcommand{\hm}{\hspace*{1em}}
\newcommand{\hmm}{\hspace*{2em}}
\newcommand{\hmmm}{\hspace*{3em}}
\newcommand{\hmmmm}{\hspace*{4em}}

\newcommand{\ie}{\emph{i.e.,}}
\newcommand{\eg}{\emph{e.g.,}}
\newcommand{\etc}{\emph{etc.}}

% ----------------
% Set slide numbering to be on bottom left

\pagestyle{fancy}
\fancyhf{}

\lhead{\it Intro to RISC-V ISA}
\rhead{\docversion}

\lfoot{\footnotesize R.S.Nikhil}
\rfoot{\footnotesize Slide \thepage}

% ****************************************************************

\begin{document}

% ================================================================
% Title page

\vspace*{0.5in}

\begin{center}\Huge
  \emph{Introduction to the RISC-V ISA}

  \vspace*{0.5in}

  Rishiyur S. Nikhil \\
  {\docversion}

  \vspace*{1in}

  \includegraphics[scale=0.7]{Figs/Bluespec_Logo_2022-10.jpg}

  \vfill

  \begin{minipage}{8in}\Large
    These slides (with sources) are available at: \url{https://github.com/rsnikhil/RISC-V_Intro}

    \vspace{1ex}

    {\bf Disclaimer:} any errors/opinions herein should be attributed
    only to the author and not to RISC-V International or to
    Bluespec, Inc.
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% Contents

\begin{center}
  {\Huge Contents}

  \vspace{0.2in}

  \begin{minipage}{6in}\Large
    \begin{itemize}

    \item RISC-V: general information

    \item RISC-V ISA's modular organization
      \begin{itemize}
      \item I(nteger) + optional extensions M, A, F, D, C, ...
      \item Unprivileged and Privileged
      \end{itemize}

    \item Unprivileged ISA overview (I, M, A, F, D, C)

    \item Memory and I/O

    \item Privileged ISA
      \begin{itemize}
      \item CSRs (Control and Status registers)
      \item Exceptions (traps and interrupts)
      \item Virtual Memory in Supervisor and User privilege levels
      \end{itemize}

    \item Common artefacts attached to cores:
      \begin{itemize}
      \item Software Interruptor, Timer with timer interrupts
      \item PLIC: Platform-Level Interrupt controller
      \item Debug Module
      \end{itemize}

    \item Comments on RISC-V software ecosystem

    \item Verification
      \begin{itemize}
      \item Formal Specification of RISC-V ISA
      \item Golden reference models
      \item Standard ISA tests
      \item Other tests
      \end{itemize}
    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% "RISC-V" is only an ISA

\begin{figure}[htp]
    \centering
    {\Huge The term \emph{RISC-V}, per se, is ``only'' an ISA (Instruction Set Architecture)}

    \vspace{0.5in}

    \begin{minipage}{11in}\LARGE
      \begin{itemize}
      \item Only a specification, a document, describing:
        \begin{itemize}
        \item ``Architecturally-visible'' state: registers (PC, integer, PC, floating point, CSRs)
        \item Repertoire of instructions, and binary representation of each one
        \item Semantics (meaning) of each instruction: how it
          accesses/changes architecturally visible state
        \end{itemize}
        {\ie} it's the abstract view of the machine targeted by
        general-purpose compilers, or the Assembly Languages
        programmer's view

      \item Not an actual CPU, processor, chip, core, ...

      \item \emph{Not within the purview of the ISA}:
        micro-architectural choices in particular implementations,
        such as pipeline structure, instruction pre-fetch,
        branch-prediction and other speculation, bypassing,
        superscalarity, out-of-order execution, multithreading,
        caches, MHz, CPI, energy consumption, {\etc}

        There can be a variety of implementations varying widely on
        these dimensions, from IoT microcontrollers to server-class
        cores to supercomputing cores.
      \end{itemize}

      \vspace{0.5in}

      \begin{center}
        \emph{This Introduction is \emph{only} about the ISA, not any specific RISC-V implementation}
      \end{center}
    \end{minipage}
\end{figure}

\clearpage

% ================================================================
% Primary References

\begin{center}\LARGE
  {\Huge Primary References}

  \vspace{0.5in}

  \begin{minipage}{9in}
    Unprivileged and Privileged ISAs:

    \begin{itemize}
    \item \emph{The RISC-V Instruction Set Manual; Volume I:
    Unprivileged ISA, Document Version 20191213}, Andrew Waterman and
      Krste Asanović (editors), December 13, 2019, 238 pp.

    \item \emph{The RISC-V Instruction Set Manual; Volume II: Privileged Architecture,
    Document Version 20211203}, Andrew Waterman, Krste Asanović1 and John Hauser (editors)
      December 4, 2021, 155 pp.
    \end{itemize}

    \vspace{1in}

    PDFs for all RISC-V specs can be found at:

    \vspace{2ex}

    \centering \url{https://riscv.org/technical/specifications/}

  \end{minipage}

\end{center}

\clearpage

% ================================================================
% Cleanliness etc.

\begin{center}\LARGE
  {\Huge Clean-slate design}

  \vspace{1in}

  \begin{minipage}{9in}
    RISC-V was created circa. 2010, at University of California,
    Berkeley, USA, by a team with 4-5 decades of experience in ISA
    design and implementations (with colleagues who are experts in
    operating systems, programming languages and compilers, and
    software tools and ecosystems).

    \begin{itemize}
    \item U.C.Berkeley created four previous RISC designs starting in
      the 1980s (hence the ``V'' in ``RISC-V''), including the parent
      design of the {\bf SPARC} ISA (commercialized by Sun
      Microsystems, Oracle, Fujitsu, ...).
    \end{itemize}
  \end{minipage}

  \vspace{1in}

  \begin{minipage}{9in}
    Result:
    \begin{itemize}
    \item \emph{Very} clean, orthogonal, simple design.
    \item No legacy bloat ({\eg} branch-delay slots, ...)
    \item Compare: ARM’s 64-bit architecture (ARM v8-A) spec is over 6000 pages long.
    \end{itemize}
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% RISC-V is an open ISA

\begin{center}
  {\Huge RISC-V is an \emph{Open} ISA, unlike other ISAs}

  \vspace{0.5in}

  \begin{minipage}{9in}\LARGE
    \begin{itemize}

    \item There are many well-known, mature ISAs---x86, ARMv8,
      Power, Sparc, ...---but they are all \emph{proprietary},
      requiring licenses and fees if you want to implement them.

    \item RISC-V does not require any license fee to
      implement.$^1$

      \begin{itemize}
      \item This is central to all the current commercial interest in RISC-V.
      \item This is central to \emph{architecture researchers} who
        wish to innovate on state-of-the-art implementations, and
        indeed was the original motivation behind the creation of
        RISC-V by a team at Univ. of California, Berkeley.
      \end{itemize}

    \item Because it is \emph{open}, and already relatively
      mature, RISC-V seems well on its way to becoming one of the
      \emph{three dominant ISAs} (along with x86 and ARM).
      \begin{itemize}
      \item It has already displaced ARM in many situations.
      \item As high-performance versions of RISC-V become available,
        it will likely display x86 as well in many situations.
      \item It is already displacing numerous lesser-known ISAs used
        for microcontrollers and in embedded systems.
      \end{itemize}

    \end{itemize}
  \end{minipage}

\vfill

{$^1$ The name ``RISC-V'' is owned by RISC-V International, and you
  need their permission to use the name in commercial naming of
  products.}
\end{center}

\clearpage

% ================================================================
% The RISC-V ISA has a Modular Organization

\begin{center}
{\Huge
  The RISC-V ISA has a \emph{Modular} Organization}

\vspace*{0.3in}

{\includegraphics[scale=0.7]{Figs/ISA_Modularity.png}}

PDFs for all RISC-V specs can be found at: \url{https://riscv.org/technical/specifications/}

\vspace{0.5in}

\begin{minipage}{11in}
  \begin{itemize}\LARGE

  \item Many other standard extensions exist: vector, crypto, bit-manipulation, ...

  \item Implementors can choose according to target, from small
    IoT/Embedded ({\eg} RV32IC ``bare-metal'') to server-class/HPC ({\eg}
    RV64IMAFDC with vector, crypto, bit-manipulation and standard
    Privileged ISA).

  \item HW facilities allow SW to discover the configuration on which it is running.

  \end{itemize}
\end{minipage}

\end{center}

\clearpage

% ================================================================
% Top Five Fallacies About RISC-V

\begin{center}
  {\Huge Top Five Fallacies About RISC-V and its Potential for Growth/Dominance}

  \vspace{1in}

  \begin{minipage}{9in}\LARGE
    Prof. David Patterson (University of California, Berkeley), one of
    the co-creators of the RISC-V ISA, identifies the following major
    fallacies in considering the outlook/future for RISC-V:

    \vspace{0.5in}

    \begin{enumerate}\Large

    \item RISC-V is an open-source processor, like Linux is an open-source operating system.

    \item Picking an established, closed ISA is a safer business decision than picking the open RISC-V.

    \item Closed ISAs do not have fragmented software ecosystems.

    \item RISC-V’s modularity leads to a more fragmented software ecosystem than those of closed ISAs.

    \item Given the points above, RISC-V cannot become the dominant ISA.

    \end{enumerate}

    \vspace{0.5in}

    Intrigued? See his responses at:

    \begin{center}
      \url{https://www.eetimes.com/examining-the-top-five-fallacies-about-risc-v}
    \end{center}
\end{minipage}

\end{center}

\clearpage

% ================================================================
% Instruction formats

\begin{center}
{\Huge
  Instruction formats}

\vspace{1ex}

PDFs for RISC-V specs can be found at: \url{https://riscv.org/technical/specifications/}

\vspace{0.3in}

\begin{minipage}{10in}
  \begin{itemize}\LARGE
  \item All instructions are 32-bits wide, for both RV32 and RV64.

  \item  There are very few instruction formats (simplifies hardware-decoder in CPU pipelines):
  \end{itemize}

  \vspace{0.2in}

  \hmmmm \fbox{\includegraphics[width=9in]{Figs/UNPRIV_riscv-spec-20191213_p130_Instr_Formats.png}}

  \vspace{0.2in}

  \begin{itemize}\LARGE
  \item In the optional ``C'' extension (``compressed''), instructions
    are 16-bits wide, for small-footprint systems (IoT/Embedded/Edge).
    \begin{itemize}
    \item Each 16-bit C instruction expands to a standard 32-bit RV32/64
      instruction; so only needs hardware at the front-end of the CPU
      pipeline (16-bit fetch and expansion).
    \end{itemize}
  \end{itemize}
\end{minipage}

\end{center}

\clearpage

% ================================================================
% Basic integer instruction set

\begin{center}
{\Huge
  Base Unpriviliged Integer ISA (with 32 32-bit or 64-bit registers)}

\vspace*{1ex}

PDFs for RISC-V specs can be found at: \url{https://riscv.org/technical/specifications/}

\vspace*{1ex}

\vfill

\begin{minipage}[t]{5in}
  \hmm \\
  \fbox{\includegraphics[width=4.5in]{Figs/UNPRIV_riscv-spec-20191213_p130_RV32I.png}}
\end{minipage}
\hm
\begin{minipage}[t]{6in}
  \hmm \\
  \begin{itemize}\large

  \item RV32I ISA (Unprivileged, 32 x 32-bit registers, integer only)
    has a mere 40 instructions (left).

  \item RV64I ISA (32 x 64-bit registers) adds 15 more instructions
    (below).

    \hmm \fbox{\includegraphics[width=4.5in]{Figs/UNPRIV_riscv-spec-20191213_p131_RV64I.png}}

    The ``W'' instructions operate on 32-bit data in 64-bit registers.

  \end{itemize}

  \vspace{0.1in}

  \begin{itemize}\large

  \item AUIPC (Add Upper Immediate to PC): enables position-independent code.

  \item Pure ``Load-Store'' ISA, {\ie} complete separation of memory
    access instructions from all other instructions (Lx, Sx).

  \item All I/O is via memory-mapped registers; no separate instructions.

  \item ECALL: (Environment Call) ``call-out'' to Privileged ISA.
    Details are part of Privileged Spec.

  \item EBREAK: ``call-out'' to debugging environment (unspecified).

  \end{itemize}
  {\Large \emph{Possibly the cleanest, most orthogonal, industrial-strength ISA ever.}}
\end{minipage}

\end{center}

\clearpage

% ================================================================
% Integer Multiply/Divide

\begin{center}
  {\Huge
    ``M'' extension: Integer Multiply and Divide instructions}

  \vspace*{0.2in}

  \begin{minipage}{9in}\Large
    \hmmmm \fbox{\includegraphics[width=7in]{Figs/UNPRIV_riscv-spec-20191213_p131_M.png}}

    \vspace{0.2in}

    \begin{itemize}

    \item S: signed; U: Unsigned: enables signed and unsigned multiplications.

    \item H: upper half of double-width data: enables 64-bit
      multiplication-results on RV32, 128-bit multiplication-results
      on RV64.

    \item The ``W'' instructions operate on 32-bit data in 64-bit registers.

    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Atomic mem ops

\begin{center}
  {\Huge
    ``A'' extension: Atomic memory operations}

  \vspace{0.2in}

  \begin{minipage}[t]{9in}
    \hmmmm \fbox{\includegraphics[width=7in]{Figs/UNPRIV_riscv-spec-20191213_p132_A.png}}

    \vspace{0.2in}

    \begin{itemize}\Large
    \item LR/SC: ``Load Reserved/Store Conditional'' on a memory location
    \item AMOxxx: atomic read-modify-writes on a memory location
    \item W ops operate on aligned 32-bit words
    \item D ops operate on aligned 64-bit words
    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Atomic mem ops

\begin{center}
  \includegraphics[width=7in]{Figs/LR_SC_AMO.png}

  \vspace{1in}

  \begin{minipage}[t]{8in}
    \begin{itemize}\Large
    \item LR/SC: Typically in a loop, until success

    \item LR/SC: Many nuances on ``address region'', ``observed by
      another hart'', number and type of instructions between the LR
      and SC, ...
    \end{itemize}

    \vspace*{5ex}

    {\large $^*$ ``hart'' $=$ ``hardware thread'', a single hardware
      thread, based on a single instruction-fetch unit}
  \end{minipage}
\end{center}


\clearpage

% ================================================================
% Single-precision Floating point

\begin{center}
{\Huge
  ``F'' extension: IEEE Single-precision Floating Point}
\end{center}

\vspace*{0.1in}

\begin{center}
  \begin{minipage}{9.5in}

  {\Large State: 32 x 32-bit floating-point registers, plus these CSRs
    (Control/Status Regs) holding standard IEEE flags:}

  \begin{center}
    \includegraphics[width=7in]{Figs/UNPRIV_riscv-spec-20191213_p136_CSRs_FD.png}
  \end{center}

  \vspace*{0.1in}

  {\Large Instructions:}

  \begin{center}
    \includegraphics[width=7in]{Figs/UNPRIV_riscv-spec-20191213_p133_RV32F.png}

    \vspace*{1ex}

    {\large\bf (... more ... please consult spec)}

    \vspace*{0.2in}

    \includegraphics[width=7in]{Figs/UNPRIV_riscv-spec-20191213_p133_RV64F.png}
  \end{center}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Double-precision Floating point

\begin{center}
{\Huge
  ``D'' extension: IEEE Double-precision Floating Point}
\end{center}

\vspace*{0.1in}

\begin{center}
  \begin{minipage}{9.5in}

    {\Large State: 32 x 64-bit floating-point registers, plus these CSRs
      (Control/Status Regs) holding standard IEEE flags:}

    \begin{center}
      \includegraphics[width=7in]{Figs/UNPRIV_riscv-spec-20191213_p136_CSRs_FD.png}
    \end{center}

    \vspace*{0.1in}

    {\Large Instructions:}

    \begin{center}
      \includegraphics[width=7in]{Figs/UNPRIV_riscv-spec-20191213_p134_RV32D.png}

      \vspace*{1ex}

      {\large\bf (... more ... please consult spec)}

      \vspace*{0.2in}

      \includegraphics[width=7in]{Figs/UNPRIV_riscv-spec-20191213_p134_RV64D.png}
    \end{center}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Compressed Instructions

\begin{center}
  {\Huge
    ``C'' extension: Compressed Instructions for smaller footprint}

  \vspace*{0.2in}

  \includegraphics[width=7in]{Figs/UNPRIV_riscv-spec-20191213_p112_RVC_Q0.png}
                                    

  \vspace*{0.1in}

  {\large\bf (... more ... please consult spec)}

  \vspace*{0.3in}

  \begin{minipage}{9in}\LARGE
    \begin{itemize}
    \item ``C'' instructions are 16-bits wide, can be packed two-to-a-32b-word.

    \item Not standalone; are mixed with standard 32-bit instructions.

    \item 3-bit register fields refer to the 8 ``most popular'' registers.

    \item Each 16-bit C instruction expands to a standard 32-bit RV32/64
      instruction; so only needs hardware at the front-end of the CPU
      pipeline (16-bit fetch and expansion).

    \item Include M, F, D instructions.
    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Memory and I/O

\begin{center}
  {\Huge
    Notes on Memory and I/O}

  \vspace{1in}

  \begin{minipage}{10in}\LARGE
    \begin{itemize}

    \item Pure ``Load-Store'' ISA (with register base-address +
      index), {\ie} total separation of memory instructions
      vs. non-memory instructions (computation, system, ...).

    \item Flat memory space (address-width depends on RV32 or RV64, and Virtual Memory Scheme).

    \item All I/O through memory-mapped device registers; no separate I/O instructions.

    \item Optional PMP CSRs (Physical Memory Protection) can impose
      base-and-bounds regions on memory with access permissions.  This
      provides lightweight sandboxing without the overheads of full
      Virtual Memory (TLBs/MMUs, page tables, address translation, ...).

    \item FENCE, FENCE.I, and SFENCE.VMA instructions for
      implementations that need to synchronize multicores, I-Caches
      and D-Caches, and TLBs/MMUs with Caches.

    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Weak Memory Models

\begin{center}
  {\Huge
    ``Weak Memory Models'' for concurrent access (in multithreading, multicore)}

  \vspace*{0.5in}

  \begin{minipage}{10in}\Large

    In multithreaded implementations, when multiple harts perform
    concurrent memory operations (fetches, loads, stores, AMOops), the
    order in which results are returned to each hart can depend on
    micro-architecural performance features such as reordering,
    caches, cache-line size, store-buffers, {\etc}.  Without a formal
    weak memory model, this can be chaotic and it becomes
    impossible/very hard to write reliable multithreaded software.

    \vspace{0.3in}

    An ISA's \emph{weak memory model} defines what are legal outcomes
    for concurrent accesses, across all implementations.  Every major
    ISA also has a defined weak memory model.
      
    \vspace{0.3in}

    In the RISC-V ISA:

    \begin{itemize}
    \item RISC-V Weak Memory Model (similar to ARMv8).

    \item Optional TSO (Total Store Order) memory model (like x86, Sparc).
    \end{itemize}

    \vspace{0.3in}

    TSO is a stronger memory model, and much legacy code is written
    assuming this model (originating on x86, Sparc).

    \vspace{0.3in}

    Code written for TSO can run on a RISC-V implementation that only
    implements the Weak Memory Model, by inserting suitable ``fence''
    instructions and ordering directives into the code.  In many
    cases, this can involve just recompiling libraries for concurrent
    data structures.
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Transition to Privileged ISA

\vspace*{3in}

\begin{center}\Huge
  \emph{Standard Privileged ISA}

\vfill

\begin{minipage}{9in}\Large
  $^*$ Because of clean ECALL from Unprivileged ISA, easy to
  substitute non-standard Privileged ISAs, {\eg} containing just basic
  trap handling for embedded applications.
\end{minipage}

\end{center}

\clearpage

% ================================================================
% Privileged ISA

\begin{center}
  {\Huge
    Standard Privileged ISA}

  \vspace*{0.5in}

  \begin{minipage}{9in}\LARGE
    {\Large Note: The separation between Unprivileged and Privileged ISAs is very
    clean.  A CPU implementation can easily implement a non-standard
    Privileged ISA with the standard Unprivileged ISA, if desired.}

    \vspace{0.5in}

    Privilege Levels: enables clean \emph{virtualization} (hypervisors, Xen, VMWare, ...)

    \begin{center}
      \begin{tabular}{|c|c|l|c|}
        \hline
        Level & Code & Name                 & Comment \\
        \hline
        3     & 11   & M (Machine)          & Highest privilege; firmware, boot loaders, ... \\
        2     & 10   & \hmm \emph{Reserved} & \\
        1     & 01   & S (Supervisor)       & Operating systems (like Linux) \\
        0     & 00   & U (User/Application) & Applications \\
        \hline
      \end{tabular}
    \end{center}

    \vspace{0.5in}

    Implementations do not have to implement all privilege levels
    (implementation cost tradeoff).  Standard combinations:

    \begin{center}
      \begin{tabular}{|c|c|}
        \hline
        Implemented Levels & Intended Usage \\
        \hline
        M                  &   Simple embedded systems (``bare metal'') \\
        M,U                &   Secure embedded systems \\
        M,S,U              &   Full OS + apps \\
        \hline
      \end{tabular}
    \end{center}
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% Privileged ISA

\begin{center}
  {\Huge
    Standard Privileged ISA: CSRs (Control and Status Registers)}

  \vspace*{0.2in}

  \begin{minipage}{9.5in}\Large
    \begin{itemize}

      \item CSRs: additional set of registers in the CPU, identified
        by 12-bit CSR number.  Thus, up to 4096 possible CSRs, but
        most are optional; only a small handful are essential in an
        implementation.

      \item CSRs can be accessed programmatically with the CSR
        instructions shown below, each of which atomically swaps the
        contents of a CSR with standard integer registers, with some
        variations and nuances.

        \hmmmm \fbox{\includegraphics[width=6in]{Figs/CSR_instrs.png}}

        \hm

        \hmmmm \includegraphics[width=6in]{Figs/CSRRW.png}

        \hm

      \item The upper 4 bits of a CSR's number specifies which privilege
        levels can access that particular CSR, and with which
        ops (read, read/write).

      \item Some CSRs are ``shadows'' of other CSRs: when viewed at
        lower privilege levels, only some bits may be visible, or may
        be read-only vs. read-write, {\etc}.

        Example: {\tt cycle} (User privilege) is a read-only shadow of
        {\tt mcycle} (Machine privilege).
    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% CSRs User-Level

\begin{center}
  {\Huge
    CSRs accessible from User level}

  \vspace*{0.2in}

  \begin{minipage}{9in}\LARGE
    \begin{center}
      \includegraphics[width=7in]{Figs/CSRs_User_Level.png}
    \end{center}

    \begin{itemize}
    \item CSRs for floating point

    \item CSRs for timing: real-time, cycle, instruction count

    \item CSRs for other performance counters (implementation-defined)
    \end{itemize}
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% CSRs Supervisor-Level

\begin{center}
  {\Huge
    CSRs accessible from Supervisor level}

  \vspace*{0.2in}

  \begin{minipage}{9in}\LARGE
    \begin{center}
      \includegraphics[width=7in]{Figs/CSRs_Supervisor.png}
    \end{center}

    \begin{itemize}
    \item CSRs for handling exceptions (traps and interrupts) at Supervisor level (see later slides)

    \item {\tt satp}: for Virtual memory (see later slides)
    \end{itemize}
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% CSRs Machine-Level

\begin{center}
  {\Huge
    CSRs accessible from Machine level}

  \vspace*{0.2in}

  \begin{minipage}{9in}\LARGE
    \begin{center}
      \includegraphics[width=7in]{Figs/CSRs_Machine_Level.png}

      {\large\bf (... more ... please consult spec)}
    \end{center}

    \begin{itemize}
    \item CSRs for configuration discovery from software

    \item CSRs for handling exceptions (traps and interrupts) at Machine level (see later slides)
    \end{itemize}
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% Exceptions

\begin{center}
  {\Huge
    Exceptions (Traps and Interrupts)}

  \vspace*{0.2in}

  \fbox{\includegraphics[width=7in]{Figs/Exception_Handling.png}}

  \vspace*{0.2in}

  \begin{minipage}{10.5in}\Large

    \begin{itemize}
    \item {\tt mtvec} (exception handler address) has been pre-loaded
      before this scenario (by boot-loader, OS, ...)

    \item {\tt mepc} may be updated by the trap handler to PC3 $=$
      PC1+0, PC1+2, PC1+4, or something else entirely, depending on
      whether the trapping instruction needs to be retried or skipped,
      whether it is a compressed instruction (+2) or not (+4), and
      whether we're resuming the trapping code or switching to an
      entirely different thread ({\eg} OS thread-switching after
      time-slice).

    \item ``Arguments'' and ``results'' are passed in registers,
      according to a calling convention/ABI (Application Binary
      Interface).

    \item Can be nested, {\ie} exception handler may itself encounter trap/interrupt.

    \item Exceptions can be delivered at Machine and Supervisor privilege levels.

    \item The ISA defines mechanisms to automatically \emph{delegate}
      exception-handling to a lower privilege level (Supervisor, User);
      see {\tt medeleg} and {\tt mideleg} CSRs.
    \end{itemize}
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% CSR MStatus

\begin{center}
  {\Huge
    CSR MStatus}

  \vspace*{0.3in}

  \begin{minipage}{9.5in}\Large
    \begin{center}
      \includegraphics[width=8in]{Figs/CSR_RV64_MStatus.png}
    \end{center}

    \vspace*{0.3in}

    \begin{itemize}
    \item {\tt mstatus} is quite central and critical, and
      manipulation of its bits involves some complexity and subtlety;
      we recommend reading the spec very closely and carefully.

    \item Various bits represent a 2-level ``stack'' (indexed by
      privilege level) that are conceptually pushed on exception entry
      and popped on returns from exceptions (see ``update status'' on
      previous slide).  These include interrupt enable bits (MIE/MPIE,
      SIE/SPIE), previous privilege level (MPP, SPP).

    \item The RV32 version of {\tt mstatus} omits some of the bits.

    \item There is also an {\tt sstatus} CSR at Supervisor level,
      which is similar to, but only a subset of {\tt mstatus}.
    \end{itemize}
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% CSR MCause

\begin{center}
  {\Huge
    CSR MCause}

  \vspace*{0.2in}

  \begin{minipage}[t]{4in}
    \hmm

    \includegraphics[width=4in]{Figs/CSR_MCause.png}
  \end{minipage}
  \hm
  \begin{minipage}[t]{5in}
    \hmm

    \vspace{1in}

    \begin{itemize}\Large
    \item On any exception, the cause is recorded in CSR {\tt mcause}
      during the transfer of control to the exception handler.

    \item Exception-handler code uses {\tt mcause} to discover what kind
      of event caused this exception, using which it can branch to
      event-type-specific handlers.
    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% CSRs MIP and MIE

\begin{center}
  {\Huge
    CSRs MIP and MIE}

  \vspace*{0.2in}

  \includegraphics[width=6in]{Figs/CSRs_MIP_MIE.png}

  \vspace*{0.3in}

  \begin{minipage}[t]{9.5in}
    \begin{itemize}\LARGE

    \item Interrupts arrive at a RISC-V hart only via the {\tt mip} CSR.

    \item Both are full-width registers (32b in RV32, 64b in RV64) but
      only the bottom 16 bits have standard definitions.

    \item {\tt mip}: Machine-level register for Interrupts-pending (there
      is also an {\tt sip} for Supervisor level).  The bits can be set
      by various sources of interrupts outside the CPU (see other slides
      on CLIC and PLIC for examples).

    \item Sources can be external devices (``E''), timers (``T'') and
      inter-processor software interrupts (``S'').

    \item {\tt mie}: Machine-level register for Interrupts-enabled (there
      is also an {\tt sie} for Supervisor level).  The CPU can mask-out
      specific source of interrupts by writing 0 to the corresponding
      bit.

    \end{itemize}

    \vspace{0.5in}

  \end{minipage}
\end{center}

\clearpage

% ===================================================================
% Virtual Memory

\begin{center}
  {\Huge
    Virtual Memory}

  \vspace*{1in}

  \begin{minipage}[t]{10in}
    \begin{itemize}\LARGE
 
    \item Virtual Memory (VM) is available in Supervisor and User privilege
      levels. \\
      Most Linux OS code runs at Supervisor level.

    \item VM is optional; an implementation can have Supervisor and
      User levels without implementing VM.

    \item The Privileged ISA spec defines several possible virtual memory schemes:
      \begin{itemize}
        \item For RV32: \emph{Sv32}
        \item For RV64: \emph{Sv39}, \emph{Sv48} and \emph{Sv57}
      \end{itemize}

      {\large
      (XX in SvXX indicates the width of virtual addresses.)

      \emph{Next two slides illustrate Sv32 and Sv39,
      respectively, the two most common variants.}}

    \item Implementations can choose \emph{how} to implement VM, in
      particular VA$\rightarrow$PA translation:

      \begin{itemize}
      \item in hardware or firmware or trap-handlers;
      \item whether to use accelerators like TLBs (Translation Look-aside Buffers),
      \item {\etc}
        \vspace{2ex}

      \item The SFENCE.VMA instruction is available to synchronize updates to
        address-translation hardware.
      \end{itemize}

    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Sv32 Page Table

\begin{center}
  {\Huge
    Virtual Memory Page Table for RV32/Sv32 using CSR {\tt satp}}

  \vspace*{0.2in}

  \fbox{\includegraphics[width=7in]{Figs/VM_Sv32.png}}

  \vspace*{0.3in}

  \begin{minipage}[t]{11in}\Large
    \begin{itemize}

    \item When running in VM mode (indicated by {\tt mstatus} bits,
      privilege level, {\etc}), the PC, and addresses in LD/ST
      instructions are VAs (Virtual Addresses).

    \item CSR {\tt satp} contains a pointer to a 2-level tree.  Each
      node in the tree is a \emph{PTN} (Page Table Node), an aligned
      4KiB block containing 1024 \emph{PTEs} (Page Table Entries, each
      32b).  Bits in each PTE indicate whether it is valid/invalid, a
      leaf (pointing to a data page), or a pointer to the next-level
      PTN.

    \item Leaves at level 1 point at 2MiB naturally aligned ``megapages'';
      leaves at level 0 point at 4KiB naturally aligned ``pages'';

    \item Sv32 addresses have 32 bits. 10-bit fields are used to index
      a PTE in a PTN, and the 12 LSBs are used to index a byte in a
      4KiB page.

      \item If a VA$\rightarrow$PA translation fails (encounter
        invalid PTE, protection failure, ...) it raises a \emph{page
        fault} exception or an \emph{access fault} exception, which is
        handled in the usual way (see ``Exceptions'' slide earlier).
    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Sv39 Page Table

\begin{center}
  {\Huge
    Virtual Memory Page Table for RV64/Sv39 using CSR {\tt satp}}

  \vspace*{0.1in}

  \fbox{\includegraphics[width=9in]{Figs/VM_Sv39.png}}

  \vspace*{0.2in}

  \begin{minipage}[t]{11in}\large
    \begin{itemize}

    \item When running in VM mode (indicated by {\tt mstatus} bits,
      privilege level, {\etc}), the PC, and addresses in LD/ST
      instructions are VAs (Virtual Addresses).

    \item CSR {\tt satp} contains a pointer to a 3-level tree.  Each
      node in the tree is a \emph{PTN} (Page Table Node), an aligned
      4KiB block containing 512 \emph{PTEs} (Page Table Entries, each
      64b).  Bits in each PTE indicate whether it is valid/invalid, a
      leaf (pointing to a data page), or a pointer to the next-level
      PTN.

    \item Leaves at level 2 point at 1GiB naturally aligned ``gigapages'';
      leaves at level 1 point at 2MiB naturally aligned ``megapages'';
      leaves at level 0 point at 4KiB naturally aligned ``pages'';

    \item Sv39 addresses have 39 bits (bits above this are
      unused). 9-bit fields are used to index a PTE in a PTN, and the
      12 LSBs are used to index a byte in a 4KiB page.

      \item If a VA$\rightarrow$PA translation fails (encounter
        invalid PTE, protection failure, ...) it raises a \emph{page
        fault} exception or an \emph{access fault} exception, which is
        handled in the usual way (see ``Exceptions'' slide earlier).
    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Transition to Adjunct System Components

\vspace*{3in}

\begin{center}\Huge
  \emph{Common System Components adjunct to RISC-V cores}

\vfill

\end{center}

\clearpage

% ================================================================
% Common System Components

\begin{center}
  {\Huge
    Common System Components adjunct to RISC-V Cores}

  \vspace*{1in}

  \fbox{\includegraphics[width=7in]{Figs/Common_System_Components.png}}

  \vspace*{0.5in}

  {\LARGE Each is described in more detail in the following slides.}

\end{center}

\clearpage

% ================================================================
% Timer

\begin{center}
  {\Huge
    Timer: Common System Component accompanying RISC-V Cores}

  \vspace*{0.2in}

  \fbox{\includegraphics[width=6in]{Figs/Timer.png}}

  \vspace*{0.3in}

  \begin{minipage}[t]{9in}
    \begin{itemize}\LARGE
    \item For SW to measure real-time, and for real-time timer interrupts.
    \item Contains two memory-mapped registers, MTIME and MTIMECMP.
    \item MTIME ticks upwards constantly (can also be written by CPU to initialize).
    \item Timer Interrupts: typical usage:
      \begin{itemize}
      \item CPU reads MTIME (let's call it $t$)
      \item CPU writes $t + \delta$ in MTIMECMP
      \item When MTIME ticks up by $\delta$ (so MTIME $\geq$
        MTIMECMP), delivers an interrupt to CSR MIP at the MTIP bit position.
      \end{itemize}
    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% SW Interruptor

\begin{center}
  {\Huge
    SW Interruptor: Common System Component accompanying RISC-V Cores}

  \vspace*{0.2in}

  \fbox{\includegraphics[width=6in]{Figs/SW_Interruptor.png}}

  \vspace*{0.3in}

  \begin{minipage}[t]{9in}
    \begin{itemize}\LARGE
    \item For a hart to deliver a ``sofware interrupt'' to another (or same) hart.
    \item Illustration shows only two harts, but there could be more (multicore).
    \item Contains one memory-mapped register, MSIP
    \item SW Interruptor: typical usage:
      \begin{itemize}
      \item Hart $I$ writes MSIP [$J$] to deliver a SW interrupt to hart $J$
      \item MSIP [$J$] is connected to the CSR MIP at the MSIP bit position (in core $J$).
      \end{itemize}
    \end{itemize}

    \vspace{0.3in}

    \begin{center}
    {\large In some systems MTIME, MTIMECMP, MSIP are in a common
      component called the \emph{CLINT} (Core-Local Interruptor).}
    \end{center}

  \end{minipage}
\end{center}

\clearpage

% ================================================================
% PLIC

\begin{center}
  {\Huge
    PLIC: Common System Component accompanying RISC-V Cores}

  \vspace*{0.5in}

  \fbox{\includegraphics[width=6in]{Figs/PLIC.png}}

  \vspace*{0.5in}

  \begin{minipage}[t]{9in}
    \begin{itemize}\LARGE

    \item Conceptually a matrix connecting an interrupt request line
      from a device to MIP[MEIP] or MIP[SEIP] of any of multiple harts.

    \item Illustration shows only two harts, but there could be more (multicore).

    \item Matrix nodes can be programmed by MMIO from cores to
      configure connectivity, priority, arbitration, interrupt masks, {\etc}

    \item A device interrupt can connect to multiple cores; PLIC has
      facilities for competing core to ``claim'' an interrupt
      atomically.
    \end{itemize}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Debug Module

\begin{center}
  {\Huge
    Debug Module: Common System Component accompanying RISC-V Cores}

  \vspace*{0.2in}

  \fbox{\includegraphics[width=4in]{Figs/Debug_Module.png}}

  \vspace*{0.3in}

  \begin{minipage}[t]{9in}
    \begin{itemize}\Large

    \item A RISC-V Debug Module is a HW module closely connected to
      multiple harts.  Can control them individually and collectively.

    \item Functions: Reset hart, read/write registers and CSRs,
      read/write memory, stop/start/continue/single-step, set
      breakpoints, set watchpoints, ...

    \item Is controlled through a standard memory-like Debug Module
      Interface (DMI).

    \item DMI can be connected to JTAG (open-source RTL available).

    \item JTAG can connect to standard, open-source OpenOCD (Open On-Chip Debugger).

    \item DMI or OpenOCD can connect to standard GDB.
    \end{itemize}

    \vspace{1ex}

    {\Large With the Debug Module, a hardware RISC-V core can be
      controlled precisely from GDB and/or OpenOCD, starting at the
      very first instruction out of reset.}
  \end{minipage}
\end{center}

\clearpage

% ================================================================
% RISC-V Software

\begin{center}
  {\Huge
    A Brief Note about the RISC-V Software Ecosystem}

  \vspace*{1in}

  \begin{minipage}{9in}\LARGE
    The following SW development tools have been available for many
    years and are mature (upstreamed into standard distributions):

    \begin{itemize}
    \item GNU toolchain (gcc, gdb, ...)
    \item Linux, FreeRTOS, seL4, ...
    \end{itemize}

    \vspace{1in}

    Hundreds/thousands of other porting efforts are underway
    (operating systems, programming language implementations,
    applications, tools), in hundreds/thousands of companies and
    universities worldwide; the ecosystem grows every day.

  \end{minipage}

\end{center}

\clearpage

% ================================================================
% Transition to Verification

\begin{center}\Huge
  \vspace*{2in}

  \emph{HW Verification of CPU and System Implementations}

  \vspace*{1in}
  
  \begin{minipage}{7in}\LARGE
    \begin{itemize}
    \item Formal and Reference Models of RISC-V CPUs
    \item Standard ISA Tests
    \item Google open source ``riscv-dv'' instruction stream generator
    \end{itemize}
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% Formal and Reference Models of RISC-V CPUs

\begin{center}
  {\Huge
    Formal Specification of RISC-V ISA}

  \vspace*{0.5in}

  \begin{minipage}{9in}\LARGE
    RISC-V is the \emph{only} major ISA with a public formal specification.$^*$

    \vspace{3ex}

    Formal Specification (Unprivileged RV32/64 IMAFDC, Privileged):
    \begin{itemize}
    \item The formal spec itself: \url{https://github.com/riscv/sail-riscv}

    \item ``A Tour of the RISC-V ISA Formal Specification'':
      \url{https://github.com/rsnikhil/RISCV_ISA_Spec_Tour} by
      R.S.Nikhil, RISC-V Summit 2019.
      Video: \url{https://www.youtube.com/watch?v=k3NhEtk8TAs}
    \end{itemize}

    \vspace{1ex}

    Written in {\bf Sail}, a language (DSL) for ISA formal specifications from U.Cambridge, UK:
    \begin{itemize}
    \item Sail has also been used for a full formal spec for ARMv8
      ISA, and for partial formal specs for Power, MIPs and x86.
    \item Sail website: \url{https://github.com/rems-project/sail}.
    \item Tutorial: ``High Level Sail Overview'', by Bill McSpadden, RISC-V Summit 2022.
    \end{itemize}

    \vspace{1ex}

    The formal spec can be compiled into a simulator for RISC-V, which
    can be used as a golden reference model.

  \end{minipage}

  \vfill

  \begin{minipage}{9in}\LARGE
    {\Large
    $^*$ We believe ARMv8 also has a formal specification, but only available internally inside ARM.}
  \end{minipage}


\end{center}

\clearpage

% ================================================================
% Golden reference models

\begin{center}
  {\Huge
    Golden Reference Models of the RISC-V ISA}

  \vspace*{0.5in}

  \begin{minipage}{9in}\LARGE
    Software simulators:
    \begin{itemize}\Large

    \item These are pure simulators of the ISA, and do not simulate
      any micro-architectural details (pipelining, caches, MMUs, ...).
      They can produce an instruction trace that can be compared with
      the instruction trace from a hardware implementation.

    \item SPIKE (The ``Golden Spike'') is the principal simulator reference model written in C++ \\
      \url{https://github.com/riscv-software-src/riscv-isa-sim}\\

    \item Other:
      \begin{itemize}
      \item Sail RISC-V formal spec, compiled to an executable.
      \item In QEMU, TinyEMU, Imperas, ... (\emph{many})
      \item Open-source formal spec written in Haskell:
        \url{https://github.com/rsnikhil/Forvis_RISCV-ISA-Spec}
      \end{itemize}
    \end{itemize}

    \vspace{2ex}

    Hardware reference models:
    \begin{itemize}\Large

    \item These are synthesizable HW implementations of RISC-V written
      for clarity (correctness), not performance, and can be run in HW
      (typically in FPGAs or HW simulation), adjacent to a real HW
      implementation, to compare ISA traces directly (``Tandem
      Verification'').

    \item Examples:
      \begin{itemize}
      \item RVBS, from U.Cambridge, UK: \url{https://github.com/CTSRD-CHERI/RVBS}
      \item Magritte, from Bluespec, Inc.
      \end{itemize}
    \end{itemize}

  \end{minipage}
\end{center}

\clearpage

% ================================================================
% Standard ISA Tests

\begin{center}
  {\Huge
    Standard ISA Tests}

  \vspace*{0.2in}

  \begin{minipage}{9in}\Large
    \begin{itemize}
    \item Reference: \url{https://github.com/riscv-software-src/riscv-tests}
    \item These are a set of several hundred programs, written in RISC-V Assembly language.
    \item Each program focuses on one particular opcode, and contains several test 1..N.
      \begin{itemize}
        \item Each test ends with a postlude that either signals
          success, or failure with an indication of which of its N tests first failed.

        \item The result signal is to store a value to a memory-mapped
          {\tt tohost} location.  Different implementations implement
          this in different ways.
      \end{itemize}
    \item The test programs are named according to the ISA modular structure. Examples:
    \end{itemize}

  \end{minipage}

  \vspace {0.1in}

  \fbox{\includegraphics[width=6in]{Figs/ISA_Test_Naming.png}}
\end{center}

\clearpage

% ================================================================
% Other Tests

\begin{center}
  {\Huge
    Other Verification Tests}

  \vspace*{0.5in}

  \begin{minipage}{9in}\LARGE
    Google open source ``riscv-dv'' instruction stream generator

    \begin{itemize}
    \item Reference: \url{https://github.com/google/riscv-dv} \\
    ``RISCV-DV is a SV/UVM based open-source instruction
      generator for RISC-V processor verification.''

    \item Typically run on reference golden model, and on DUT, and compare
      instruction traces.
    \end{itemize}

    \vspace*{0.5in}

    Beyond ISA tests, HW verification is often performed by comparing
    behavior of reference golden model against HW implementation while
    booting an OS, typically Linux.

    \vspace*{0.5in}

    \emph{Would be useful:} Test code whose execution time in
    simulation is between ISA tests (seconds) and Linux kernel (days),
    gradually adding virtual memory, interrupts, and
    process-switching:

    \begin{itemize}
    \item ISA tests' execution time: seconds (even in simulation).
    \item Linux kernel execution time: Many hours/days in simulation.
    \end{itemize}
    
    Perhaps a microkernel (seL4?) may serve this purpose.

  \end{minipage}
\end{center}

\clearpage

% ================================================================
% END slide

\begin{center}\Huge
  \vspace*{2in}

  \emph{End}

  \vspace*{2in}
  
  \begin{minipage}{7in}\Large
    \begin{center}
      \emph{Please direct questions/comments/errata to the author.}
    \end{center}
  \end{minipage}

\end{center}

\clearpage

% ================================================================
% Extra: TODO

\begin{center}
  {\Huge
    Possible topics to add in future}

  \vspace*{1in}

  \begin{minipage}{9in}\LARGE
    \begin{itemize}
    \item Verification under non-determinism ({\eg} with timer interrupts; multicore)
    \item Tandem Verification
    \item Verification of Weak Memory Model implementations
    \item Formal Verification
    \end{itemize}
  \end{minipage}

\end{center}

\clearpage

% ================================================================

\end{document}
